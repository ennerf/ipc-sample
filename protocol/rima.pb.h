// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rima.proto

#ifndef PROTOBUF_rima_2eproto__INCLUDED
#define PROTOBUF_rima_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
// @@protoc_insertion_point(includes)
namespace hebi {
namespace rima {
namespace proto {
class AdaptiveSurface;
class AdaptiveSurfaceDefaultTypeInternal;
extern AdaptiveSurfaceDefaultTypeInternal _AdaptiveSurface_default_instance_;
class ExplorerRequest;
class ExplorerRequestDefaultTypeInternal;
extern ExplorerRequestDefaultTypeInternal _ExplorerRequest_default_instance_;
class ExplorerResponse;
class ExplorerResponseDefaultTypeInternal;
extern ExplorerResponseDefaultTypeInternal _ExplorerResponse_default_instance_;
class ImageGridSpec;
class ImageGridSpecDefaultTypeInternal;
extern ImageGridSpecDefaultTypeInternal _ImageGridSpec_default_instance_;
class SharedImageResult;
class SharedImageResultDefaultTypeInternal;
extern SharedImageResultDefaultTypeInternal _SharedImageResult_default_instance_;
}  // namespace proto
}  // namespace rima
}  // namespace hebi

namespace hebi {
namespace rima {
namespace proto {

namespace protobuf_rima_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_rima_2eproto

// ===================================================================

class ImageGridSpec : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:hebi.rima.proto.ImageGridSpec) */ {
 public:
  ImageGridSpec();
  virtual ~ImageGridSpec();

  ImageGridSpec(const ImageGridSpec& from);

  inline ImageGridSpec& operator=(const ImageGridSpec& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ImageGridSpec& default_instance();

  static inline const ImageGridSpec* internal_default_instance() {
    return reinterpret_cast<const ImageGridSpec*>(
               &_ImageGridSpec_default_instance_);
  }

  void Swap(ImageGridSpec* other);

  // implements Message ----------------------------------------------

  inline ImageGridSpec* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageGridSpec* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ImageGridSpec& from);
  void MergeFrom(const ImageGridSpec& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ImageGridSpec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 num_x = 1;
  bool has_num_x() const;
  void clear_num_x();
  static const int kNumXFieldNumber = 1;
  ::google::protobuf::uint32 num_x() const;
  void set_num_x(::google::protobuf::uint32 value);

  // required uint32 num_z = 2;
  bool has_num_z() const;
  void clear_num_z();
  static const int kNumZFieldNumber = 2;
  ::google::protobuf::uint32 num_z() const;
  void set_num_z(::google::protobuf::uint32 value);

  // required float start_x = 3;
  bool has_start_x() const;
  void clear_start_x();
  static const int kStartXFieldNumber = 3;
  float start_x() const;
  void set_start_x(float value);

  // required float start_z = 4;
  bool has_start_z() const;
  void clear_start_z();
  static const int kStartZFieldNumber = 4;
  float start_z() const;
  void set_start_z(float value);

  // required float step_x = 5;
  bool has_step_x() const;
  void clear_step_x();
  static const int kStepXFieldNumber = 5;
  float step_x() const;
  void set_step_x(float value);

  // required float step_z = 6;
  bool has_step_z() const;
  void clear_step_z();
  static const int kStepZFieldNumber = 6;
  float step_z() const;
  void set_step_z(float value);

  // @@protoc_insertion_point(class_scope:hebi.rima.proto.ImageGridSpec)
 private:
  void set_has_num_x();
  void clear_has_num_x();
  void set_has_num_z();
  void clear_has_num_z();
  void set_has_start_x();
  void clear_has_start_x();
  void set_has_start_z();
  void clear_has_start_z();
  void set_has_step_x();
  void clear_has_step_x();
  void set_has_step_z();
  void clear_has_step_z();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 num_x_;
  ::google::protobuf::uint32 num_z_;
  float start_x_;
  float start_z_;
  float step_x_;
  float step_z_;
  friend struct  protobuf_rima_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AdaptiveSurface : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:hebi.rima.proto.AdaptiveSurface) */ {
 public:
  AdaptiveSurface();
  virtual ~AdaptiveSurface();

  AdaptiveSurface(const AdaptiveSurface& from);

  inline AdaptiveSurface& operator=(const AdaptiveSurface& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AdaptiveSurface& default_instance();

  static inline const AdaptiveSurface* internal_default_instance() {
    return reinterpret_cast<const AdaptiveSurface*>(
               &_AdaptiveSurface_default_instance_);
  }

  void Swap(AdaptiveSurface* other);

  // implements Message ----------------------------------------------

  inline AdaptiveSurface* New() const PROTOBUF_FINAL { return New(NULL); }

  AdaptiveSurface* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const AdaptiveSurface& from);
  void MergeFrom(const AdaptiveSurface& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AdaptiveSurface* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float surface_points = 3 [packed = true];
  int surface_points_size() const;
  void clear_surface_points();
  static const int kSurfacePointsFieldNumber = 3;
  float surface_points(int index) const;
  void set_surface_points(int index, float value);
  void add_surface_points(float value);
  const ::google::protobuf::RepeatedField< float >&
      surface_points() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_surface_points();

  // required float X0_out = 1;
  bool has_x0_out() const;
  void clear_x0_out();
  static const int kX0OutFieldNumber = 1;
  float x0_out() const;
  void set_x0_out(float value);

  // required float DX_out = 2;
  bool has_dx_out() const;
  void clear_dx_out();
  static const int kDXOutFieldNumber = 2;
  float dx_out() const;
  void set_dx_out(float value);

  // @@protoc_insertion_point(class_scope:hebi.rima.proto.AdaptiveSurface)
 private:
  void set_has_x0_out();
  void clear_has_x0_out();
  void set_has_dx_out();
  void clear_has_dx_out();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< float > surface_points_;
  mutable int _surface_points_cached_byte_size_;
  float x0_out_;
  float dx_out_;
  friend struct  protobuf_rima_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SharedImageResult : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:hebi.rima.proto.SharedImageResult) */ {
 public:
  SharedImageResult();
  virtual ~SharedImageResult();

  SharedImageResult(const SharedImageResult& from);

  inline SharedImageResult& operator=(const SharedImageResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SharedImageResult& default_instance();

  static inline const SharedImageResult* internal_default_instance() {
    return reinterpret_cast<const SharedImageResult*>(
               &_SharedImageResult_default_instance_);
  }

  void Swap(SharedImageResult* other);

  // implements Message ----------------------------------------------

  inline SharedImageResult* New() const PROTOBUF_FINAL { return New(NULL); }

  SharedImageResult* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SharedImageResult& from);
  void MergeFrom(const SharedImageResult& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SharedImageResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float image_data = 8 [packed = true];
  int image_data_size() const;
  void clear_image_data();
  static const int kImageDataFieldNumber = 8;
  float image_data(int index) const;
  void set_image_data(int index, float value);
  void add_image_data(float value);
  const ::google::protobuf::RepeatedField< float >&
      image_data() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_image_data();

  // required .hebi.rima.proto.ImageGridSpec image_grid_spec = 10;
  bool has_image_grid_spec() const;
  void clear_image_grid_spec();
  static const int kImageGridSpecFieldNumber = 10;
  const ::hebi::rima::proto::ImageGridSpec& image_grid_spec() const;
  ::hebi::rima::proto::ImageGridSpec* mutable_image_grid_spec();
  ::hebi::rima::proto::ImageGridSpec* release_image_grid_spec();
  void set_allocated_image_grid_spec(::hebi::rima::proto::ImageGridSpec* image_grid_spec);

  // optional .hebi.rima.proto.AdaptiveSurface adaptive_surface = 11;
  bool has_adaptive_surface() const;
  void clear_adaptive_surface();
  static const int kAdaptiveSurfaceFieldNumber = 11;
  const ::hebi::rima::proto::AdaptiveSurface& adaptive_surface() const;
  ::hebi::rima::proto::AdaptiveSurface* mutable_adaptive_surface();
  ::hebi::rima::proto::AdaptiveSurface* release_adaptive_surface();
  void set_allocated_adaptive_surface(::hebi::rima::proto::AdaptiveSurface* adaptive_surface);

  // required uint64 sequence_id = 1;
  bool has_sequence_id() const;
  void clear_sequence_id();
  static const int kSequenceIdFieldNumber = 1;
  ::google::protobuf::uint64 sequence_id() const;
  void set_sequence_id(::google::protobuf::uint64 value);

  // optional uint64 encoder1_count = 2;
  bool has_encoder1_count() const;
  void clear_encoder1_count();
  static const int kEncoder1CountFieldNumber = 2;
  ::google::protobuf::uint64 encoder1_count() const;
  void set_encoder1_count(::google::protobuf::uint64 value);

  // optional uint64 encoder2_count = 3;
  bool has_encoder2_count() const;
  void clear_encoder2_count();
  static const int kEncoder2CountFieldNumber = 3;
  ::google::protobuf::uint64 encoder2_count() const;
  void set_encoder2_count(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hebi.rima.proto.SharedImageResult)
 private:
  void set_has_sequence_id();
  void clear_has_sequence_id();
  void set_has_encoder1_count();
  void clear_has_encoder1_count();
  void set_has_encoder2_count();
  void clear_has_encoder2_count();
  void set_has_image_grid_spec();
  void clear_has_image_grid_spec();
  void set_has_adaptive_surface();
  void clear_has_adaptive_surface();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< float > image_data_;
  mutable int _image_data_cached_byte_size_;
  ::hebi::rima::proto::ImageGridSpec* image_grid_spec_;
  ::hebi::rima::proto::AdaptiveSurface* adaptive_surface_;
  ::google::protobuf::uint64 sequence_id_;
  ::google::protobuf::uint64 encoder1_count_;
  ::google::protobuf::uint64 encoder2_count_;
  friend struct  protobuf_rima_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExplorerResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:hebi.rima.proto.ExplorerResponse) */ {
 public:
  ExplorerResponse();
  virtual ~ExplorerResponse();

  ExplorerResponse(const ExplorerResponse& from);

  inline ExplorerResponse& operator=(const ExplorerResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ExplorerResponse& default_instance();

  static inline const ExplorerResponse* internal_default_instance() {
    return reinterpret_cast<const ExplorerResponse*>(
               &_ExplorerResponse_default_instance_);
  }

  void Swap(ExplorerResponse* other);

  // implements Message ----------------------------------------------

  inline ExplorerResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  ExplorerResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ExplorerResponse& from);
  void MergeFrom(const ExplorerResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExplorerResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hebi.rima.proto.SharedImageResult shared_image_result = 1;
  bool has_image_result() const;
  void clear_image_result();
  static const int kImageResultFieldNumber = 1;
  const ::hebi::rima::proto::SharedImageResult& image_result() const;
  ::hebi::rima::proto::SharedImageResult* mutable_image_result();
  ::hebi::rima::proto::SharedImageResult* release_image_result();
  void set_allocated_image_result(::hebi::rima::proto::SharedImageResult* image_result);

  // @@protoc_insertion_point(class_scope:hebi.rima.proto.ExplorerResponse)
 private:
  void set_has_image_result();
  void clear_has_image_result();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::hebi::rima::proto::SharedImageResult* image_result_;
  friend struct  protobuf_rima_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExplorerRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:hebi.rima.proto.ExplorerRequest) */ {
 public:
  ExplorerRequest();
  virtual ~ExplorerRequest();

  ExplorerRequest(const ExplorerRequest& from);

  inline ExplorerRequest& operator=(const ExplorerRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ExplorerRequest& default_instance();

  static inline const ExplorerRequest* internal_default_instance() {
    return reinterpret_cast<const ExplorerRequest*>(
               &_ExplorerRequest_default_instance_);
  }

  void Swap(ExplorerRequest* other);

  // implements Message ----------------------------------------------

  inline ExplorerRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ExplorerRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ExplorerRequest& from);
  void MergeFrom(const ExplorerRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExplorerRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hebi.rima.proto.ExplorerRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct  protobuf_rima_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ImageGridSpec

// required uint32 num_x = 1;
inline bool ImageGridSpec::has_num_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageGridSpec::set_has_num_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageGridSpec::clear_has_num_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageGridSpec::clear_num_x() {
  num_x_ = 0u;
  clear_has_num_x();
}
inline ::google::protobuf::uint32 ImageGridSpec::num_x() const {
  // @@protoc_insertion_point(field_get:hebi.rima.proto.ImageGridSpec.num_x)
  return num_x_;
}
inline void ImageGridSpec::set_num_x(::google::protobuf::uint32 value) {
  set_has_num_x();
  num_x_ = value;
  // @@protoc_insertion_point(field_set:hebi.rima.proto.ImageGridSpec.num_x)
}

// required uint32 num_z = 2;
inline bool ImageGridSpec::has_num_z() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageGridSpec::set_has_num_z() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageGridSpec::clear_has_num_z() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageGridSpec::clear_num_z() {
  num_z_ = 0u;
  clear_has_num_z();
}
inline ::google::protobuf::uint32 ImageGridSpec::num_z() const {
  // @@protoc_insertion_point(field_get:hebi.rima.proto.ImageGridSpec.num_z)
  return num_z_;
}
inline void ImageGridSpec::set_num_z(::google::protobuf::uint32 value) {
  set_has_num_z();
  num_z_ = value;
  // @@protoc_insertion_point(field_set:hebi.rima.proto.ImageGridSpec.num_z)
}

// required float start_x = 3;
inline bool ImageGridSpec::has_start_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageGridSpec::set_has_start_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageGridSpec::clear_has_start_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageGridSpec::clear_start_x() {
  start_x_ = 0;
  clear_has_start_x();
}
inline float ImageGridSpec::start_x() const {
  // @@protoc_insertion_point(field_get:hebi.rima.proto.ImageGridSpec.start_x)
  return start_x_;
}
inline void ImageGridSpec::set_start_x(float value) {
  set_has_start_x();
  start_x_ = value;
  // @@protoc_insertion_point(field_set:hebi.rima.proto.ImageGridSpec.start_x)
}

// required float start_z = 4;
inline bool ImageGridSpec::has_start_z() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImageGridSpec::set_has_start_z() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImageGridSpec::clear_has_start_z() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImageGridSpec::clear_start_z() {
  start_z_ = 0;
  clear_has_start_z();
}
inline float ImageGridSpec::start_z() const {
  // @@protoc_insertion_point(field_get:hebi.rima.proto.ImageGridSpec.start_z)
  return start_z_;
}
inline void ImageGridSpec::set_start_z(float value) {
  set_has_start_z();
  start_z_ = value;
  // @@protoc_insertion_point(field_set:hebi.rima.proto.ImageGridSpec.start_z)
}

// required float step_x = 5;
inline bool ImageGridSpec::has_step_x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ImageGridSpec::set_has_step_x() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ImageGridSpec::clear_has_step_x() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ImageGridSpec::clear_step_x() {
  step_x_ = 0;
  clear_has_step_x();
}
inline float ImageGridSpec::step_x() const {
  // @@protoc_insertion_point(field_get:hebi.rima.proto.ImageGridSpec.step_x)
  return step_x_;
}
inline void ImageGridSpec::set_step_x(float value) {
  set_has_step_x();
  step_x_ = value;
  // @@protoc_insertion_point(field_set:hebi.rima.proto.ImageGridSpec.step_x)
}

// required float step_z = 6;
inline bool ImageGridSpec::has_step_z() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ImageGridSpec::set_has_step_z() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ImageGridSpec::clear_has_step_z() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ImageGridSpec::clear_step_z() {
  step_z_ = 0;
  clear_has_step_z();
}
inline float ImageGridSpec::step_z() const {
  // @@protoc_insertion_point(field_get:hebi.rima.proto.ImageGridSpec.step_z)
  return step_z_;
}
inline void ImageGridSpec::set_step_z(float value) {
  set_has_step_z();
  step_z_ = value;
  // @@protoc_insertion_point(field_set:hebi.rima.proto.ImageGridSpec.step_z)
}

// -------------------------------------------------------------------

// AdaptiveSurface

// required float X0_out = 1;
inline bool AdaptiveSurface::has_x0_out() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdaptiveSurface::set_has_x0_out() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdaptiveSurface::clear_has_x0_out() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdaptiveSurface::clear_x0_out() {
  x0_out_ = 0;
  clear_has_x0_out();
}
inline float AdaptiveSurface::x0_out() const {
  // @@protoc_insertion_point(field_get:hebi.rima.proto.AdaptiveSurface.X0_out)
  return x0_out_;
}
inline void AdaptiveSurface::set_x0_out(float value) {
  set_has_x0_out();
  x0_out_ = value;
  // @@protoc_insertion_point(field_set:hebi.rima.proto.AdaptiveSurface.X0_out)
}

// required float DX_out = 2;
inline bool AdaptiveSurface::has_dx_out() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdaptiveSurface::set_has_dx_out() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdaptiveSurface::clear_has_dx_out() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdaptiveSurface::clear_dx_out() {
  dx_out_ = 0;
  clear_has_dx_out();
}
inline float AdaptiveSurface::dx_out() const {
  // @@protoc_insertion_point(field_get:hebi.rima.proto.AdaptiveSurface.DX_out)
  return dx_out_;
}
inline void AdaptiveSurface::set_dx_out(float value) {
  set_has_dx_out();
  dx_out_ = value;
  // @@protoc_insertion_point(field_set:hebi.rima.proto.AdaptiveSurface.DX_out)
}

// repeated float surface_points = 3 [packed = true];
inline int AdaptiveSurface::surface_points_size() const {
  return surface_points_.size();
}
inline void AdaptiveSurface::clear_surface_points() {
  surface_points_.Clear();
}
inline float AdaptiveSurface::surface_points(int index) const {
  // @@protoc_insertion_point(field_get:hebi.rima.proto.AdaptiveSurface.surface_points)
  return surface_points_.Get(index);
}
inline void AdaptiveSurface::set_surface_points(int index, float value) {
  surface_points_.Set(index, value);
  // @@protoc_insertion_point(field_set:hebi.rima.proto.AdaptiveSurface.surface_points)
}
inline void AdaptiveSurface::add_surface_points(float value) {
  surface_points_.Add(value);
  // @@protoc_insertion_point(field_add:hebi.rima.proto.AdaptiveSurface.surface_points)
}
inline const ::google::protobuf::RepeatedField< float >&
AdaptiveSurface::surface_points() const {
  // @@protoc_insertion_point(field_list:hebi.rima.proto.AdaptiveSurface.surface_points)
  return surface_points_;
}
inline ::google::protobuf::RepeatedField< float >*
AdaptiveSurface::mutable_surface_points() {
  // @@protoc_insertion_point(field_mutable_list:hebi.rima.proto.AdaptiveSurface.surface_points)
  return &surface_points_;
}

// -------------------------------------------------------------------

// SharedImageResult

// required uint64 sequence_id = 1;
inline bool SharedImageResult::has_sequence_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SharedImageResult::set_has_sequence_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SharedImageResult::clear_has_sequence_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SharedImageResult::clear_sequence_id() {
  sequence_id_ = GOOGLE_ULONGLONG(0);
  clear_has_sequence_id();
}
inline ::google::protobuf::uint64 SharedImageResult::sequence_id() const {
  // @@protoc_insertion_point(field_get:hebi.rima.proto.SharedImageResult.sequence_id)
  return sequence_id_;
}
inline void SharedImageResult::set_sequence_id(::google::protobuf::uint64 value) {
  set_has_sequence_id();
  sequence_id_ = value;
  // @@protoc_insertion_point(field_set:hebi.rima.proto.SharedImageResult.sequence_id)
}

// optional uint64 encoder1_count = 2;
inline bool SharedImageResult::has_encoder1_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SharedImageResult::set_has_encoder1_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SharedImageResult::clear_has_encoder1_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SharedImageResult::clear_encoder1_count() {
  encoder1_count_ = GOOGLE_ULONGLONG(0);
  clear_has_encoder1_count();
}
inline ::google::protobuf::uint64 SharedImageResult::encoder1_count() const {
  // @@protoc_insertion_point(field_get:hebi.rima.proto.SharedImageResult.encoder1_count)
  return encoder1_count_;
}
inline void SharedImageResult::set_encoder1_count(::google::protobuf::uint64 value) {
  set_has_encoder1_count();
  encoder1_count_ = value;
  // @@protoc_insertion_point(field_set:hebi.rima.proto.SharedImageResult.encoder1_count)
}

// optional uint64 encoder2_count = 3;
inline bool SharedImageResult::has_encoder2_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SharedImageResult::set_has_encoder2_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SharedImageResult::clear_has_encoder2_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SharedImageResult::clear_encoder2_count() {
  encoder2_count_ = GOOGLE_ULONGLONG(0);
  clear_has_encoder2_count();
}
inline ::google::protobuf::uint64 SharedImageResult::encoder2_count() const {
  // @@protoc_insertion_point(field_get:hebi.rima.proto.SharedImageResult.encoder2_count)
  return encoder2_count_;
}
inline void SharedImageResult::set_encoder2_count(::google::protobuf::uint64 value) {
  set_has_encoder2_count();
  encoder2_count_ = value;
  // @@protoc_insertion_point(field_set:hebi.rima.proto.SharedImageResult.encoder2_count)
}

// repeated float image_data = 8 [packed = true];
inline int SharedImageResult::image_data_size() const {
  return image_data_.size();
}
inline void SharedImageResult::clear_image_data() {
  image_data_.Clear();
}
inline float SharedImageResult::image_data(int index) const {
  // @@protoc_insertion_point(field_get:hebi.rima.proto.SharedImageResult.image_data)
  return image_data_.Get(index);
}
inline void SharedImageResult::set_image_data(int index, float value) {
  image_data_.Set(index, value);
  // @@protoc_insertion_point(field_set:hebi.rima.proto.SharedImageResult.image_data)
}
inline void SharedImageResult::add_image_data(float value) {
  image_data_.Add(value);
  // @@protoc_insertion_point(field_add:hebi.rima.proto.SharedImageResult.image_data)
}
inline const ::google::protobuf::RepeatedField< float >&
SharedImageResult::image_data() const {
  // @@protoc_insertion_point(field_list:hebi.rima.proto.SharedImageResult.image_data)
  return image_data_;
}
inline ::google::protobuf::RepeatedField< float >*
SharedImageResult::mutable_image_data() {
  // @@protoc_insertion_point(field_mutable_list:hebi.rima.proto.SharedImageResult.image_data)
  return &image_data_;
}

// required .hebi.rima.proto.ImageGridSpec image_grid_spec = 10;
inline bool SharedImageResult::has_image_grid_spec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SharedImageResult::set_has_image_grid_spec() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SharedImageResult::clear_has_image_grid_spec() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SharedImageResult::clear_image_grid_spec() {
  if (image_grid_spec_ != NULL) image_grid_spec_->::hebi::rima::proto::ImageGridSpec::Clear();
  clear_has_image_grid_spec();
}
inline const ::hebi::rima::proto::ImageGridSpec& SharedImageResult::image_grid_spec() const {
  // @@protoc_insertion_point(field_get:hebi.rima.proto.SharedImageResult.image_grid_spec)
  return image_grid_spec_ != NULL ? *image_grid_spec_
                         : *::hebi::rima::proto::ImageGridSpec::internal_default_instance();
}
inline ::hebi::rima::proto::ImageGridSpec* SharedImageResult::mutable_image_grid_spec() {
  set_has_image_grid_spec();
  if (image_grid_spec_ == NULL) {
    image_grid_spec_ = new ::hebi::rima::proto::ImageGridSpec;
  }
  // @@protoc_insertion_point(field_mutable:hebi.rima.proto.SharedImageResult.image_grid_spec)
  return image_grid_spec_;
}
inline ::hebi::rima::proto::ImageGridSpec* SharedImageResult::release_image_grid_spec() {
  // @@protoc_insertion_point(field_release:hebi.rima.proto.SharedImageResult.image_grid_spec)
  clear_has_image_grid_spec();
  ::hebi::rima::proto::ImageGridSpec* temp = image_grid_spec_;
  image_grid_spec_ = NULL;
  return temp;
}
inline void SharedImageResult::set_allocated_image_grid_spec(::hebi::rima::proto::ImageGridSpec* image_grid_spec) {
  delete image_grid_spec_;
  image_grid_spec_ = image_grid_spec;
  if (image_grid_spec) {
    set_has_image_grid_spec();
  } else {
    clear_has_image_grid_spec();
  }
  // @@protoc_insertion_point(field_set_allocated:hebi.rima.proto.SharedImageResult.image_grid_spec)
}

// optional .hebi.rima.proto.AdaptiveSurface adaptive_surface = 11;
inline bool SharedImageResult::has_adaptive_surface() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SharedImageResult::set_has_adaptive_surface() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SharedImageResult::clear_has_adaptive_surface() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SharedImageResult::clear_adaptive_surface() {
  if (adaptive_surface_ != NULL) adaptive_surface_->::hebi::rima::proto::AdaptiveSurface::Clear();
  clear_has_adaptive_surface();
}
inline const ::hebi::rima::proto::AdaptiveSurface& SharedImageResult::adaptive_surface() const {
  // @@protoc_insertion_point(field_get:hebi.rima.proto.SharedImageResult.adaptive_surface)
  return adaptive_surface_ != NULL ? *adaptive_surface_
                         : *::hebi::rima::proto::AdaptiveSurface::internal_default_instance();
}
inline ::hebi::rima::proto::AdaptiveSurface* SharedImageResult::mutable_adaptive_surface() {
  set_has_adaptive_surface();
  if (adaptive_surface_ == NULL) {
    adaptive_surface_ = new ::hebi::rima::proto::AdaptiveSurface;
  }
  // @@protoc_insertion_point(field_mutable:hebi.rima.proto.SharedImageResult.adaptive_surface)
  return adaptive_surface_;
}
inline ::hebi::rima::proto::AdaptiveSurface* SharedImageResult::release_adaptive_surface() {
  // @@protoc_insertion_point(field_release:hebi.rima.proto.SharedImageResult.adaptive_surface)
  clear_has_adaptive_surface();
  ::hebi::rima::proto::AdaptiveSurface* temp = adaptive_surface_;
  adaptive_surface_ = NULL;
  return temp;
}
inline void SharedImageResult::set_allocated_adaptive_surface(::hebi::rima::proto::AdaptiveSurface* adaptive_surface) {
  delete adaptive_surface_;
  adaptive_surface_ = adaptive_surface;
  if (adaptive_surface) {
    set_has_adaptive_surface();
  } else {
    clear_has_adaptive_surface();
  }
  // @@protoc_insertion_point(field_set_allocated:hebi.rima.proto.SharedImageResult.adaptive_surface)
}

// -------------------------------------------------------------------

// ExplorerResponse

// optional .hebi.rima.proto.SharedImageResult shared_image_result = 1;
inline bool ExplorerResponse::has_image_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExplorerResponse::set_has_image_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExplorerResponse::clear_has_image_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExplorerResponse::clear_image_result() {
  if (image_result_ != NULL) image_result_->::hebi::rima::proto::SharedImageResult::Clear();
  clear_has_image_result();
}
inline const ::hebi::rima::proto::SharedImageResult& ExplorerResponse::image_result() const {
  // @@protoc_insertion_point(field_get:hebi.rima.proto.ExplorerResponse.shared_image_result)
  return image_result_ != NULL ? *image_result_
                         : *::hebi::rima::proto::SharedImageResult::internal_default_instance();
}
inline ::hebi::rima::proto::SharedImageResult* ExplorerResponse::mutable_image_result() {
  set_has_image_result();
  if (image_result_ == NULL) {
    image_result_ = new ::hebi::rima::proto::SharedImageResult;
  }
  // @@protoc_insertion_point(field_mutable:hebi.rima.proto.ExplorerResponse.shared_image_result)
  return image_result_;
}
inline ::hebi::rima::proto::SharedImageResult* ExplorerResponse::release_image_result() {
  // @@protoc_insertion_point(field_release:hebi.rima.proto.ExplorerResponse.shared_image_result)
  clear_has_image_result();
  ::hebi::rima::proto::SharedImageResult* temp = image_result_;
  image_result_ = NULL;
  return temp;
}
inline void ExplorerResponse::set_allocated_image_result(::hebi::rima::proto::SharedImageResult* image_result) {
  delete image_result_;
  image_result_ = image_result;
  if (image_result) {
    set_has_image_result();
  } else {
    clear_has_image_result();
  }
  // @@protoc_insertion_point(field_set_allocated:hebi.rima.proto.ExplorerResponse.shared_image_result)
}

// -------------------------------------------------------------------

// ExplorerRequest

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace proto
}  // namespace rima
}  // namespace hebi

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_rima_2eproto__INCLUDED
