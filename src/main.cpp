/*
Minimum example for sending a dummy image as generated by the
 AFM API via Aeron IPC.
*/

#include "Aeron.h"
#include "dummy_api.h"
#include "rima.pb.h"
#include <iostream>
#include <thread>

// Aeron publication settings
static std::shared_ptr<aeron::Publication> responsePub;
const std::string CHANNEL = "aeron:ipc"; // ipc => shared memory
const std::int32_t IMAGE_STREAM_ID = 1003;

// Reusable memory for serialization
hebi::rima::proto::ExplorerResponse msg;
std::vector<std::uint8_t> tx_buffer(4 * 1024 * 1024);
aeron::concurrent::AtomicBuffer aeron_tx_buffer(tx_buffer.data(),
                                                tx_buffer.size());

// Fill protobuf message and send on IPC
void image_result_callback(void *user_parameter, image_grid_specification& grid_spec, shared_image_result& data) {

  // Metadata fields (optional)
  auto image_msg = msg.mutable_image_result();
  image_msg->set_sequence_id(data.sequence_id());
  image_msg->set_encoder1_count(data.encoder1_count());
  image_msg->set_encoder2_count(data.encoder2_count());

  // Copy intensity pixel data
  auto image_data = image_msg->mutable_image_data();
  image_data->Resize(data.image_data_length(), 0);
  memcpy(image_data->mutable_data(), data.image_data(),
         data.image_data_length() * sizeof(float));

  // Add grid_msg information
  auto grid_msg = image_msg->mutable_image_grid_spec();
  grid_msg->set_num_x(grid_spec.numX);
  grid_msg->set_num_z(grid_spec.numZ);
  grid_msg->set_start_x(grid_spec.startX);
  grid_msg->set_start_z(grid_spec.startZ);
  grid_msg->set_step_x(grid_spec.stepX);
  grid_msg->set_step_z(grid_spec.stepZ);

  // Add extracted surface (NOTE: looks like there is a
  // bug and contains_adaptive_surface returns the inverse)
  if (!data.contains_adaptive_surface()) {
    auto surface_msg = image_msg->mutable_adaptive_surface();
    auto surface_msg_points = surface_msg->mutable_surface_points();
    surface_msg_points->Resize(data.num_surface_points(), 0);

    // Get directly into message
    float X0_out, DX_out;
    data.get_surface(surface_msg_points->mutable_data(), X0_out, DX_out);
    surface_msg->set_x0_out(X0_out);
    surface_msg->set_dx_out(DX_out);
  }

  // Serialization
  auto numBytes = msg.ByteSize();
  if (responsePub && numBytes <= tx_buffer.size()) {
    // Serialize as Protobuf
    if (msg.SerializeToArray(tx_buffer.data(), numBytes)) {
      // Send via Aeron
      responsePub->offer(aeron_tx_buffer, 0, numBytes);
    }
  } else {
    printf(">>>> Failed to send sequence %zu\n", data.sequence_id());
  }
  msg.Clear();
}

int main() {

  // Connect to Aeron
  auto aeron = aeron::Aeron::connect();
  std::int64_t id = aeron->addPublication(CHANNEL, IMAGE_STREAM_ID);
  responsePub = aeron->findPublication(id);

  // wait for the publication to be valid
  while (!responsePub) {
    std::this_thread::yield();
    responsePub = aeron->findPublication(id);
  }

  const std::int64_t channelStatus = responsePub->channelStatus();
  std::cout << "Publication channel status (id="
            << responsePub->channelStatusId() << ") "
            << (channelStatus ==
                        aeron::ChannelEndpointStatus::CHANNEL_ENDPOINT_ACTIVE
                    ? "ACTIVE"
                    : std::to_string(channelStatus))
            << std::endl;

  image_grid_specification image_grid_spec(0,40,10,50);
  shared_image_result image_result(image_grid_spec);

  for (int i = 0; i < 10000; ++i) {
    // Fill with arbitrary data
    image_result.fill_data((float)(i % 128));

    // Serialize in the callback
     image_result_callback(nullptr, image_grid_spec, image_result);

    // ~1 KHz
    std::this_thread::sleep_for(std::chrono::milliseconds (1));
  }

  return 0;
}